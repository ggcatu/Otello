Todas las corridas fueron realizadas en una computadora con las siguientes 
especificaciones:

Procesador: Intel® Core™ i7-3770 CPU @ 3.40GHz × 8 
RAM: 8GB
SO: Ubuntu 14 64 bits

Proyecto 2
Inteligencia Artificial I

12-11006 Gabriel Gimenez
12-11075 Anthony El Kareh
12-10694 Eliot Díaz

Implementación y evaluación de algoritmos de juegos para una versión 
reducida del juego de othello.

                           Actividad 1
---------------------------------------------------------------------------

Para completar la representacion del juego, se procedio a agregar las verificaciones faltantes en las diagonales para chequear
si el tablero esta dentro de los limites requeridos y para poder moverse de un estado a otro. Ademas se coloco una condicion 
especial en la funcion que genera movimientos validos, la cual permite que el vector de movimientos nunca este vacio ya que en
caso de no haber ningun movimiento valido, se coloca el movimiento 36 con el cual no se hace nada.  

---------------------------------------------------------------------------
Actividad 2
---------------------------------------------------------------------------

Para la implementacion de los algoritmos, se utilizaron los pseudocodigos vistos en clase, en lugar de llamadas a funciones como
max y min de la libreria cmath de c++, se utilizaron operadores ternarios para aumentar la velocidad de ejecucion y ahorrar tiempo.
En el programa principal, en la condicion de llamada al algoritmo scout, se agrego la multiplicacion por el color al obtener el res
ultado, ya que al igual que minmax-maxmin, este siempre retorna el valor del jugador MAX por lo tanto para que el vlue obtenido siem
pre reporte -4, hacia falta esta multiplicacion.

---------------------------------------------------------------------------
				           Conclusiones
---------------------------------------------------------------------------


Para generar las conclusiones expresadas en este informe, se procedió programando los 4 algoritmos pedidos por la asignación,
y los mismos se corrieron durante un lapso de 10 minutos, bajo las mismas condiciones (CPU, Memoria).

Sobre Minmax y Negamax(Minmax):
	
	Minmax
	18. White moves: value=-4, #expanded=625084814, #generated=876269597, seconds=229.718, #generated/second=3.81454e+06

	Negamax
	18. White moves: value=-4, #expanded=625084814, #generated=876269597, seconds=250.962, #generated/second=3.49164e+06

	Dado que básicamente son el mismo algoritmo, y el segundo solo busca elminar la doble recursion, vemos que se comportan casi iguales.
	La cantidad de nodos generadas asi como de nodos expandidos, es la misma, como era de esperarse.
	Por otro lado, vemos una pequeña discrepancia en cuanto al tiempo total, la cual es minima, sin embargo esto puede deberse a los para
	metros que son pasados en las llamadas, ya que estos aumentan el tiempo de ejecucion del programa, de esta mismo forma en cada llamada al algoritmo negamax, se debe modificar el color del jugador lo cual tambien genera una pequeña perdida de tiempo al momento de correr el algoritmo.

	Vemos que estos algoritmos, no lograron llegar tan "lejos", como los otros, ya que en efecto, generan demasiados nodos y no buscan podas en el arbol de juego por lo tanto les es muy dificil avanzar en poco tiempo sobre variaciones principales con mas nodos generados.

Negamax(Alpha - Beta):
	
	18. White moves: value=-4, #expanded=960343, #generated=1259429, seconds=0.456114, #generated/second=2.76122e+06

	Podemos notar, que a la misma profundidad que llegó Minmax, la poda del Alpha-Beta pruning, nos permitió generar casi 1/900 de los nodos
	generados anteriormente, lo que provocó que el algoritmo se adentrase en el arbol mucho mas rápido, (alrededor de 500 veces).

	13. Black moves: value=-4, #expanded=315074162, #generated=415909955, seconds=142.768, #generated/second=2.91319e+06

	La poda de nodos, nos permitio avanzar 5 variaciones principales mas, tambien podemos notar que la cantidad de nodos generados en la variacion mas alta que alcanzo el algoritmo, es aproximadamente la mitad de los nodos que generaron negamax y minmax en la variacion 18.

Scout y NegaScout

	Scout
	12. White moves: value=-4, #expanded=693495, #generated=1247342, seconds=253.415, #generated/second=4922.13

	Negascout
	12. White moves: value=-4, #expanded=477003110, #generated=623011942, seconds=218.247, #generated/second=2.85461e+06


	Podemos notar, que estos son los 2 "mejores" algoritmos de los 5 implementados para esta entrega, ambos lograron llegar mas "lejos" que todos los demas y en un tiempo excepcional, sin embargo hay ciertas consideraciones a tomar sobre ambos.

	En el caso de scout, podemos ver que testear el poder o no meterse por una rama del arbol reduce la cantidad de nodos generados en unas 577 veces, lo cual nos ahorra muchisima memoria ya que no se revisan ramas innecesarias del arbol. Sin embargo, negascout es mas veloz que scout, ya que a pesar de generar una cantidad mucho mayor de nodos, las llamadas a test en scout toman un tiempo prudencial para determinar si se explorara o no una rama, en cambio negascout ignora ese procedimiento llevando sus cotas (alpha y beta) en todo momento del algoritmo. 